#!/usr/bin/python3

# mp5.py

import logging
import os
import sys
from itertools import product
from functools import reduce

import colorlog
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from scipy import signal

logger = logging.getLogger(__name__)
# Change this to get more, or fewer, error messages.
#   DEBUG = Show me everything.
#   INFO = Only the green text and up.
#   WARNING = Only warnings.
#   ERROR = Only (user coded) error messages.
#   CRITICAL = Only (user coded) critical error messages.
logger.setLevel(colorlog.colorlog.logging.DEBUG)

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter())
logger.addHandler(handler)

np.set_printoptions(threshold=sys.maxsize)
np.set_printoptions(linewidth=10000)
np.set_printoptions(precision=4)

# Some constants so that we know where all of our stuff is.
script_dir = os.path.dirname(__file__)
images_dir = os.path.join(script_dir, "images")
results_dir = os.path.join(script_dir, "results")
blur_dir = os.path.join(results_dir, "blur_tests")
sobel_dir = os.path.join(results_dir, "sobel_tests")
canny_dir = os.path.join(results_dir, "canny_tests")

dirs = [script_dir, images_dir, results_dir, blur_dir, sobel_dir, canny_dir]


def generate_gaussian_kernel(size=3, sigma=0.5, verbose=False):
    """Returns a 2D Gaussian mask kernel for use in 2D convolutions.

    The mask returned will be a square, (size*size) 2D matrix.

    size must be odd."""
    assert size % 2 == 1, "Gaussian size is not odd."

    if not verbose:
        logger.disabled = True

    logger.debug("Generating a Gaussian kernel,")
    logger.debug("with size {} and sigma {}.".format(size, sigma))

    logger.debug("Generating ogrids (y should be vertical, x horizontal):")
    y, x = np.ogrid[-(size // 2) : (size // 2) + 1, -(size // 2) : (size // 2) + 1]
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Squaring ogrids to make values absolutely positive.")
    x = x * x
    y = y * y
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Putting squared ogrids together to make a full,")
    logger.debug("radially symmetric meshgrid.")
    mesh = x + y
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Dividing grid by -2*sigma*sigma.")
    mesh = -1 * (mesh / (2.0 * (sigma ** 2)))
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Getting elementwise exponential, e^{grid}.")
    mesh = np.exp(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Normalizing mesh so its sum is 1.")
    mesh /= np.sum(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("New sum should be 1, and it is :: {}".format(np.sum(mesh)))

    if not verbose:
        logger.disabled = False

    return mesh


def gaussian_blur(image, kernel, verbose=False):
    """Given a Gaussian kernel like the one generated by generate_gaussian_kernel
    and an image, perform a Gaussian blur on the image and return it."""
    return signal.convolve2d(image, kernel, boundary="symm", mode="same")


def load_image(path):
    return np.asarray(Image.open(path).convert("L"))


def save_image(image_array, path):
    return Image.fromarray(image_array.astype("uint8"), "L").save(path)


def sobel(image_array):
    """Performs the Sobel operator on image_array.

    Two arrays of equal shape to image_array are reutrned, mag_img and theta_img
    respectively. mag_img is the magnitude of the intensity change; theta_img is
    the orientation of the change.
    """
    # The Sobel kernel operators are hardcoded.
    g_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    g_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])

    # Convolve the Sobel kernels with the image array.
    g_x_image = signal.convolve2d(image_array, g_x, boundary="symm", mode="same")
    g_y_image = signal.convolve2d(image_array, g_y, boundary="symm", mode="same")

    # The easiest way to combine the Sobel kernels is to just turn them into an array of
    # complex numbers.
    g_comp = g_x_image + g_y_image * 1j

    # Return the
    g_mag = np.absolute(g_comp) / np.max(np.absolute(g_comp))
    g_angle = np.angle(g_comp, True)

    return (g_mag, g_angle)


def find_hysteresis_thresholds(magnitude_data, edge_percentile):
    """Given the Sobel magnitude array and a percent to cut off with, finds a
    high and low threshold for use with the Canny edge hysteresis thresholding."""

    hist, bins = np.histogram((magnitude_data * 255).ravel(), 256, [0, 256])
    T_high = np.percentile(magnitude_data, edge_percentile)
    T_low = T_high / 2
    return T_low, T_high


def sobel_suppress_nonmaxima(sobel_mag_array, sobel_theta_array):
    """
    Uses the theta edge map  and a look-up table method to perform
    nonmaxima suppression on the input magnitude edge map.
    """
    sobel_mag_nonmaxes_suppressed = np.zeros(sobel_mag_array.shape)

    # All this lookup table tells us is which two values to check.
    LUT = {
        1: (1, 0),
        2: (1, -1),
        3: (0, -1),
        4: (-1, -1),
        5: (-1, 0),
        6: (-1, 1),
        7: (0, 1),
        0: (1, 1),
    }
    sobel_theta_array = np.copy(sobel_theta_array)
    sobel_theta_array[sobel_theta_array < 0] += 180
    sobel_theta_array += 45 / 2
    dirs = sobel_theta_array // 45 + 1
    dirs[dirs == 9] = 1
    height, width = sobel_mag_nonmaxes_suppressed.shape
    for (y, x) in product(range(height), range(width)):
        try:
            left = dirs[y, x] % 8
            right = (dirs[y, x] + 4) % 8
            ldx, ldy = LUT[left]
            rdx, rdy = LUT[right]
            if (
                sobel_mag_array[y, x] >= sobel_mag_array[y + ldy, x + ldx]
                and sobel_mag_array[y, x] >= sobel_mag_array[y + rdy, x + rdx]
            ):
                sobel_mag_nonmaxes_suppressed[y, x] = sobel_mag_array[y, x]
        except IndexError as e:
            pass
    return sobel_mag_nonmaxes_suppressed


def run_hysteresis_filter(sobel_array, t_low, t_high):
    """Given a 2D array of floating points, runs a hysteresis filter on the image.

    A hysteresis filter is a recursive filter which works in three parts. For every
    value in the array,

    1. If the value is less than t_low, automatically zero it out. It won't be
       considered.
    2. If the value is greater than t_high, set it to 1. It is automatically considered
       and endpoint in the final matrix. This is what we call a "strong edge".
    3. If the value is between t_low and t_high, it is called a weak edge. We consider
       it strong if one of its 8 neighbors is strong. (This is the part that gets
       applied recursively.)

    Weak edges that don't eventually come into contact with a strong edge eventually
    get cancelled out and become low edges. We put this data into a new matrix, to
    ensure we don't accidentally mess up with the recursion, although you could probably
    be clever enough to do this in place.
    """
    # 0.5 is used to denote a weak edge. All pixels in the array start out as
    # weak edges.
    canny_array = np.zeros(sobel_array.shape).astype("uint8")

    def canny_check_pixel(data, i, j, t_low, t_high, recurse=0, maxdepth=6):
        """Check to see whether a single pixel should be considered a strong edge,
        or a non edge, with recursion if it's a weak edge.

        By default this cuts off if we go beyond maxdepth."""
        if recurse > maxdepth:
            return False

        try:
            if data[i, j] >= t_high:
                return True
            elif data[i, j] <= t_low:
                return False
            else:
                # This looks weird, but reduce is just casting "or" over the whole
                # list.
                return reduce(
                    lambda x, y: x or y,
                    [
                        canny_check_pixel(
                            data,
                            i - 1,
                            j + 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i,
                            j + 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i + 1,
                            j + 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i - 1,
                            j,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        # canny_check_pixel(data, i, j, t_low, t_high, recurse=recurse+1, maxdepth=maxdepth), SKIP - it's us!
                        canny_check_pixel(
                            data,
                            i + 1,
                            j,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i - 1,
                            j - 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i,
                            j - 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                        canny_check_pixel(
                            data,
                            i + 1,
                            j - 1,
                            t_low,
                            t_high,
                            recurse=recurse + 1,
                            maxdepth=maxdepth,
                        ),
                    ],
                )
        except IndexError:
            # This happens naturally with recursion when we get an i, j out of bounds.
            # We just return 0 in this case. OOB pixels are considered non-edges.
            return False

    for i in range(0, sobel_array.shape[0]):
        for j in range(0, sobel_array.shape[1]):
            if canny_check_pixel(sobel_array, i, j, t_low, t_high):
                canny_array[i, j] = 255
            else:
                canny_array[i, j] = 0

    return canny_array


if __name__ == "__main__":
    logger.info("Andrew Quinn - EECS 332 - Machine Problem #5")
    logger.info("-" * (88 - 11))
    kernel = generate_gaussian_kernel(size=7, sigma=0.9)

    for dir in dirs:
        if not os.path.exists(dir):
            logger.warning("\t\t{}\t\t doesn't exist... Creating.".format(dir))
            os.makedirs(dir)

    for path, subdirs, files in os.walk(images_dir):
        for name in files:
            logger.info("Now operating on:      {}".format(os.path.join(path, name)))

            # Generate blurred images.
            blur_count = 1
            for (size, sigma) in [(3, 0.5), (5, 0.7), (7, 0.9)]:
                image = load_image(os.path.join(path, name))
                blur_name = "{}_blur_{}.bmp".format(name[:-4], blur_count)
                logger.debug(
                    "  Blurring {} with Gaussian kernel ({}, {}) to form {}".format(
                        name, size, sigma, blur_name
                    )
                )
                kernel = generate_gaussian_kernel(size, sigma)
                blurred_image = np.floor(gaussian_blur(image, kernel))
                logger.debug("  Saving {} in {}.".format(blur_name, blur_dir))
                save_image(blurred_image, os.path.join(blur_dir, blur_name))
                blur_count += 1

            # Generate Sobel-operated images.
            logger.debug(
                "  Generating Sobel-operated images (after blurring with "
                "Gaussian kernel 3, 0.5"
            )
            image = load_image(os.path.join(path, name))
            kernel = generate_gaussian_kernel()
            blurred = np.floor(gaussian_blur(image, kernel))
            sobel_mag = np.floor(255 * sobel(blurred)[0])
            sobel_mag_name = "{}_sobel_mag.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_mag_name, sobel_dir))
            save_image(sobel_mag, os.path.join(sobel_dir, sobel_mag_name))

            sobel_theta = np.floor((sobel(blurred)[1] + 180) / (360 / 255))
            sobel_theta_name = "{}_sobel_theta.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_theta_name, sobel_dir))
            save_image(sobel_theta, os.path.join(sobel_dir, sobel_theta_name))

            # Finding hysteresis thresholds.
            (t_low, t_high) = find_hysteresis_thresholds(sobel(blurred)[0], 80)
            logger.debug(
                "Hysteresis thresholds: Low {:4f}, high {:4f}".format(t_low, t_high)
            )

            # Suppressing nonmaxima.
            sobel_suppressed = sobel_suppress_nonmaxima(
                sobel(blurred)[0], sobel(blurred)[1]
            )
            sobel_mag = np.floor(255 * sobel_suppressed)
            sobel_mag_name = "{}_sobel_mag_suppressed.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_mag_name, sobel_dir))
            save_image(sobel_mag, os.path.join(sobel_dir, sobel_mag_name))

            # Performing canny edge detect.
            canny = run_hysteresis_filter(sobel_suppressed, t_low, t_high)
            canny_name = "{}_canny.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(canny_name, canny_dir))
            save_image(canny, os.path.join(canny_dir, canny_name))
