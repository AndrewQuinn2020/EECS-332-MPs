#!/usr/bin/python3

# mp5.py

import logging
import os
import sys
import itertools

import colorlog
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from scipy import signal

logger = logging.getLogger(__name__)
# Change this to get more, or fewer, error messages.
#   DEBUG = Show me everything.
#   INFO = Only the green text and up.
#   WARNING = Only warnings.
#   ERROR = Only (user coded) error messages.
#   CRITICAL = Only (user coded) critical error messages.
logger.setLevel(colorlog.colorlog.logging.DEBUG)

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter())
logger.addHandler(handler)

np.set_printoptions(threshold=sys.maxsize)
np.set_printoptions(linewidth=10000)
np.set_printoptions(precision=4)

# Some constants so that we know where all of our stuff is.
script_dir = os.path.dirname(__file__)
images_dir = os.path.join(script_dir, "images")
results_dir = os.path.join(script_dir, "results")
blur_dir = os.path.join(results_dir, "blur_tests")

dirs = [script_dir, images_dir, results_dir, blur_dir]


def generate_gaussian_kernel(size=3, sigma=0.5, verbose=False):
    """Returns a 2D Gaussian mask kernel for use in 2D convolutions.

    The mask returned will be a square, (size*size) 2D matrix.

    size must be odd."""
    assert size % 2 == 1, "Gaussian size is not odd."

    if not verbose:
        logger.disabled = True

    logger.debug("Generating a Gaussian kernel,")
    logger.debug("with size {} and sigma {}.".format(size, sigma))

    logger.debug("Generating ogrids (y should be vertical, x horizontal):")
    y, x = np.ogrid[-(size // 2) : (size // 2) + 1, -(size // 2) : (size // 2) + 1]
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Squaring ogrids to make values absolutely positive.")
    x = x * x
    y = y * y
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Putting squared ogrids together to make a full,")
    logger.debug("radially symmetric meshgrid.")
    mesh = x + y
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Dividing grid by -2*sigma*sigma.")
    mesh = -1 * (mesh / (2.0 * (sigma ** 2)))
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Getting elementwise exponential, e^{grid}.")
    mesh = np.exp(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Normalizing mesh so its sum is 1.")
    mesh /= np.sum(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("New sum should be 1, and it is :: {}".format(np.sum(mesh)))

    if not verbose:
        logger.disabled = False

    return mesh


def gaussian_blur(image, kernel, verbose=False):
    """Given a Gaussian kernel like the one generated by generate_gaussian_kernel
    and an image, perform a Gaussian blur on the image and return it."""
    return signal.convolve2d(image, kernel, boundary="symm", mode="same")


def load_image(path):
    return np.asarray(Image.open(path).convert("L"))


def save_image(image_array, path):
    return Image.fromarray(image_array.astype("uint8"), "L").save(path)


if __name__ == "__main__":
    logger.info("Andrew Quinn - EECS 332 - Machine Problem #5")
    logger.info("-" * (88 - 11))
    kernel = generate_gaussian_kernel(size=7, sigma=0.9)

    for dir in dirs:
        if not os.path.exists(dir):
            logger.warning("\t\t{}\t\t doesn't exist... Creating.".format(dir))
            os.makedirs(dir)

    for path, subdirs, files in os.walk(images_dir):
        for name in files:
            logger.info("Now operating on:      {}".format(os.path.join(path, name)))
            image = load_image(os.path.join(path, name))
            blur_count = 1
            for (size, sigma) in [(3, 0.5), (5, 0.7), (7, 0.9)]:
                blur_name = "{}_blur_{}.bmp".format(name[:-4], blur_count)
                logger.debug(
                    "Blurring {} with Gaussian kernel ({}, {}) to form {}".format(
                        name, size, sigma, blur_name
                    )
                )
                kernel = generate_gaussian_kernel(size, sigma)
                blurred_image = gaussian_blur(image, kernel)
                save_image(blurred_image, os.path.join(blur_dir, blur_name))
                blur_count += 1
