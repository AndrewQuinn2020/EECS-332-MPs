#!/usr/bin/python3

# mp5.py

import logging
import os
import sys
from itertools import product

import colorlog
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from scipy import signal

logger = logging.getLogger(__name__)
# Change this to get more, or fewer, error messages.
#   DEBUG = Show me everything.
#   INFO = Only the green text and up.
#   WARNING = Only warnings.
#   ERROR = Only (user coded) error messages.
#   CRITICAL = Only (user coded) critical error messages.
logger.setLevel(colorlog.colorlog.logging.DEBUG)

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter())
logger.addHandler(handler)

np.set_printoptions(threshold=sys.maxsize)
np.set_printoptions(linewidth=10000)
np.set_printoptions(precision=4)

# Some constants so that we know where all of our stuff is.
script_dir = os.path.dirname(__file__)
images_dir = os.path.join(script_dir, "images")
results_dir = os.path.join(script_dir, "results")
blur_dir = os.path.join(results_dir, "blur_tests")
sobel_dir = os.path.join(results_dir, "sobel_tests")

dirs = [script_dir, images_dir, results_dir, blur_dir, sobel_dir]


def generate_gaussian_kernel(size=3, sigma=0.5, verbose=False):
    """Returns a 2D Gaussian mask kernel for use in 2D convolutions.

    The mask returned will be a square, (size*size) 2D matrix.

    size must be odd."""
    assert size % 2 == 1, "Gaussian size is not odd."

    if not verbose:
        logger.disabled = True

    logger.debug("Generating a Gaussian kernel,")
    logger.debug("with size {} and sigma {}.".format(size, sigma))

    logger.debug("Generating ogrids (y should be vertical, x horizontal):")
    y, x = np.ogrid[-(size // 2) : (size // 2) + 1, -(size // 2) : (size // 2) + 1]
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Squaring ogrids to make values absolutely positive.")
    x = x * x
    y = y * y
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Putting squared ogrids together to make a full,")
    logger.debug("radially symmetric meshgrid.")
    mesh = x + y
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Dividing grid by -2*sigma*sigma.")
    mesh = -1 * (mesh / (2.0 * (sigma ** 2)))
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Getting elementwise exponential, e^{grid}.")
    mesh = np.exp(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Normalizing mesh so its sum is 1.")
    mesh /= np.sum(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("New sum should be 1, and it is :: {}".format(np.sum(mesh)))

    if not verbose:
        logger.disabled = False

    return mesh


def gaussian_blur(image, kernel, verbose=False):
    """Given a Gaussian kernel like the one generated by generate_gaussian_kernel
    and an image, perform a Gaussian blur on the image and return it."""
    return signal.convolve2d(image, kernel, boundary="symm", mode="same")


def load_image(path):
    return np.asarray(Image.open(path).convert("L"))


def save_image(image_array, path):
    return Image.fromarray(image_array.astype("uint8"), "L").save(path)


def sobel(image_array):
    """Performs the Sobel operator on image_array.

    Two arrays of equal shape to image_array are reutrned, mag_img and theta_img
    respectively. mag_img is the magnitude of the intensity change; theta_img is
    the orientation of the change.
    """
    # The Sobel kernel operators are hardcoded.
    g_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    g_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])

    # Convolve the Sobel kernels with the image array.
    g_x_image = signal.convolve2d(image_array, g_x, boundary="symm", mode="same")
    g_y_image = signal.convolve2d(image_array, g_y, boundary="symm", mode="same")

    # The easiest way to combine the Sobel kernels is to just turn them into an array of
    # complex numbers.
    g_comp = g_x_image + g_y_image * 1j

    # Return the
    g_mag = np.absolute(g_comp) / np.max(np.absolute(g_comp))
    g_angle = np.angle(g_comp, True)

    return (g_mag, g_angle)


def find_hysteresis_thresholds(magnitude_data, edge_percentile):
    """Given the Sobel magnitude array and a percent to cut off with, finds a
    high and low threshold for use with the Canny edge hysteresis thresholding."""

    hist, bins = np.histogram((magnitude_data * 255).ravel(), 256, [0, 256])
    T_high = np.percentile(magnitude_data, edge_percentile)
    T_low = T_high / 2
    return T_high, T_low


def sobel_suppress_nonmaxima(sobel_mag_array, sobel_theta_array):
    """
    Uses the theta edge map  and a look-up table method to perform
    nonmaxima suppression on the input magnitude edge map.
    """
    sobel_mag_nonmaxes_suppressed = np.zeros(sobel_mag_array.shape)
    LUT = {
        1: (1, 0),
        2: (1, -1),
        3: (0, -1),
        4: (-1, -1),
        5: (-1, 0),
        6: (-1, 1),
        7: (0, 1),
        0: (1, 1),
    }
    sobel_theta_array = np.copy(sobel_theta_array)
    sobel_theta_array[sobel_theta_array < 0] += 180
    sobel_theta_array += 45 / 2
    dirs = sobel_theta_array // 45 + 1
    dirs[dirs == 9] = 1
    height, width = sobel_mag_nonmaxes_suppressed.shape
    for (y, x) in product(range(height), range(width)):
        try:
            left = dirs[y, x] % 8
            right = (dirs[y, x] + 4) % 8
            ldx, ldy = LUT[left]
            rdx, rdy = LUT[right]
            if (
                sobel_mag_array[y, x] >= sobel_mag_array[y + ldy, x + ldx]
                and sobel_mag_array[y, x] >= sobel_mag_array[y + rdy, x + rdx]
            ):
                sobel_mag_nonmaxes_suppressed[y, x] = sobel_mag_array[y, x]
        except IndexError as e:
            pass
    return sobel_mag_nonmaxes_suppressed


if __name__ == "__main__":
    logger.info("Andrew Quinn - EECS 332 - Machine Problem #5")
    logger.info("-" * (88 - 11))
    kernel = generate_gaussian_kernel(size=7, sigma=0.9)

    for dir in dirs:
        if not os.path.exists(dir):
            logger.warning("\t\t{}\t\t doesn't exist... Creating.".format(dir))
            os.makedirs(dir)

    for path, subdirs, files in os.walk(images_dir):
        for name in files:
            logger.info("Now operating on:      {}".format(os.path.join(path, name)))

            # Generate blurred images.
            blur_count = 1
            for (size, sigma) in [(3, 0.5), (5, 0.7), (7, 0.9)]:
                image = load_image(os.path.join(path, name))
                blur_name = "{}_blur_{}.bmp".format(name[:-4], blur_count)
                logger.debug(
                    "  Blurring {} with Gaussian kernel ({}, {}) to form {}".format(
                        name, size, sigma, blur_name
                    )
                )
                kernel = generate_gaussian_kernel(size, sigma)
                blurred_image = np.floor(gaussian_blur(image, kernel))
                logger.debug("  Saving {} in {}.".format(blur_name, blur_dir))
                save_image(blurred_image, os.path.join(blur_dir, blur_name))
                blur_count += 1

            # Generate Sobel-operated images.
            logger.debug(
                "  Generating Sobel-operated images (after blurring with "
                "Gaussian kernel 3, 0.5"
            )
            image = load_image(os.path.join(path, name))
            kernel = generate_gaussian_kernel()
            blurred = np.floor(gaussian_blur(image, kernel))
            sobel_mag = np.floor(255 * sobel(blurred)[0])
            sobel_mag_name = "{}_sobel_mag.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_mag_name, sobel_dir))
            save_image(sobel_mag, os.path.join(sobel_dir, sobel_mag_name))

            sobel_theta = np.floor((sobel(blurred)[1] + 180) / (360 / 255))
            sobel_theta_name = "{}_sobel_theta.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_theta_name, sobel_dir))
            save_image(sobel_theta, os.path.join(sobel_dir, sobel_theta_name))

            # Finding hysteresis thresholds.
            (h_high, h_low) = find_hysteresis_thresholds(sobel(blurred)[0], 95)
            logger.debug("Hysteresis thresholds: High {}, low {}".format(h_high, h_low))

            sobel_suppressed = sobel_suppress_nonmaxima(
                sobel(blurred)[0], sobel(blurred)[1]
            )
            logger.debug("Sobel_suppressed looks like:\n{}".format(sobel_suppressed))
            sobel_mag = np.floor(255 * sobel_suppressed)
            sobel_mag_name = "{}_sobel_mag_suppressed.bmp".format(name[:-4])
            logger.debug("  Saving {} in {}".format(sobel_mag_name, sobel_dir))
            save_image(sobel_mag, os.path.join(sobel_dir, sobel_mag_name))
