#!/usr/bin/python3

# mp5.py

import logging
import os
import sys
import itertools

import colorlog
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from scipy import signal

logger = logging.getLogger(__name__)
# Change this to get more, or fewer, error messages.
#   DEBUG = Show me everything.
#   INFO = Only the green text and up.
#   WARNING = Only warnings.
#   ERROR = Only (user coded) error messages.
#   CRITICAL = Only (user coded) critical error messages.
logger.setLevel(colorlog.colorlog.logging.DEBUG)

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter())
logger.addHandler(handler)

np.set_printoptions(threshold=sys.maxsize)
np.set_printoptions(linewidth=10000)
np.set_printoptions(precision=4)

# Some constants so that we know where all of our stuff is.
script_dir = os.path.dirname(__file__)
images_dir = os.path.join(script_dir, "images")
results_dir = os.path.join(script_dir, "results")
blur_dir = os.path.join(results_dir, "blur_tests")
sobel_dir = os.path.join(results_dir, "sobel_tests")

dirs = [script_dir, images_dir, results_dir, blur_dir, sobel_dir]


def generate_gaussian_kernel(size=3, sigma=0.5, verbose=False):
    """Returns a 2D Gaussian mask kernel for use in 2D convolutions.

    The mask returned will be a square, (size*size) 2D matrix.

    size must be odd."""
    assert size % 2 == 1, "Gaussian size is not odd."

    if not verbose:
        logger.disabled = True

    logger.debug("Generating a Gaussian kernel,")
    logger.debug("with size {} and sigma {}.".format(size, sigma))

    logger.debug("Generating ogrids (y should be vertical, x horizontal):")
    y, x = np.ogrid[-(size // 2) : (size // 2) + 1, -(size // 2) : (size // 2) + 1]
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Squaring ogrids to make values absolutely positive.")
    x = x * x
    y = y * y
    logger.debug("y = \n{}".format(y))
    logger.debug("x = \n{}".format(x))
    logger.debug("Putting squared ogrids together to make a full,")
    logger.debug("radially symmetric meshgrid.")
    mesh = x + y
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Dividing grid by -2*sigma*sigma.")
    mesh = -1 * (mesh / (2.0 * (sigma ** 2)))
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Getting elementwise exponential, e^{grid}.")
    mesh = np.exp(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("Normalizing mesh so its sum is 1.")
    mesh /= np.sum(mesh)
    logger.debug("mesh = \n{}".format(mesh))
    logger.debug("New sum should be 1, and it is :: {}".format(np.sum(mesh)))

    if not verbose:
        logger.disabled = False

    return mesh


def gaussian_blur(image, kernel, verbose=False):
    """Given a Gaussian kernel like the one generated by generate_gaussian_kernel
    and an image, perform a Gaussian blur on the image and return it."""
    return signal.convolve2d(image, kernel, boundary="symm", mode="same")


def load_image(path):
    return np.asarray(Image.open(path).convert("L"))


def save_image(image_array, path):
    return Image.fromarray(image_array.astype("uint8"), "L").save(path)


def sobel(image_array):
    """Performs the Sobel operator on image_array.

    Two arrays of equal shape to image_array are reutrned, mag_img and theta_img
    respectively. mag_img is the magnitude of the intensity change; theta_img is
    the orientation of the change.
    """
    # The Sobel kernel operators are hardcoded.
    g_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    g_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])

    # Convolve the Sobel kernels with the image array.
    g_x_image = signal.convolve2d(image_array, g_x, boundary="symm", mode="same")
    g_y_image = signal.convolve2d(image_array, g_y, boundary="symm", mode="same")

    # The easiest way to combine the Sobel kernels is to just turn them into an array of
    # complex numbers.
    g_comp = g_x_image + g_y_image * 1j

    # Return the
    g_mag = np.absolute(g_comp) / np.max(np.absolute(g_comp))
    g_angle = np.angle(g_comp, True)

    return (g_mag, g_angle)


if __name__ == "__main__":
    logger.info("Andrew Quinn - EECS 332 - Machine Problem #5")
    logger.info("-" * (88 - 11))
    kernel = generate_gaussian_kernel(size=7, sigma=0.9)

    for dir in dirs:
        if not os.path.exists(dir):
            logger.warning("\t\t{}\t\t doesn't exist... Creating.".format(dir))
            os.makedirs(dir)

    for path, subdirs, files in os.walk(images_dir):
        for name in files:
            logger.info("Now operating on:      {}".format(os.path.join(path, name)))

            # Generate blurred images.
            blur_count = 1
            for (size, sigma) in [(3, 0.5), (5, 0.7), (7, 0.9)]:
                image = load_image(os.path.join(path, name))
                blur_name = "{}_blur_{}.bmp".format(name[:-4], blur_count)
                logger.debug(
                    "  Blurring {} with Gaussian kernel ({}, {}) to form {}".format(
                        name, size, sigma, blur_name
                    )
                )
                kernel = generate_gaussian_kernel(size, sigma)
                blurred_image = np.floor(gaussian_blur(image, kernel))
                logger.debug("  Saving {} in {}.".format(blur_name, blur_dir))
                save_image(blurred_image, os.path.join(blur_dir, blur_name))
                blur_count += 1

            # Generate Sobel-operated images.
            image = load_image(os.path.join(path, name))
            kernel = generate_gaussian_kernel()
            blurred_image = np.floor(gaussian_blur(image, kernel))
